-- //
-- //  autosqlconf.mysql.sql
-- //  zero-framework mysql autosqlconf script
-- //
-- //  Created by Zero on 2020/11/11.
-- //  Copyright © 2020年 RyeWhiskey. All rights reserved.
-- //

-- // INIT MYSQL AUTOSQLCONF DML BEGIN 

CREATE DATABASE IF NOT EXISTS `<databaseName>` DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;	
USE `<databaseName>`;
SET GLOBAL log_bin_trust_function_creators=1;

DELIMITER $$
DROP FUNCTION IF EXISTS `COLUMN_EXISTS` $$
CREATE FUNCTION  `COLUMN_EXISTS` (
	C_TABLE_SCHEMA VARCHAR(32),
	C_TABLE_NAME VARCHAR(64),
	C_COLUMN_NAME VARCHAR(64)
) RETURNS INT 
BEGIN
	DECLARE s INT;
	SELECT 
		count(1)
	FROM 
		`INFORMATION_SCHEMA`.`COLUMNS`
	WHERE
		`TABLE_SCHEMA` = C_TABLE_SCHEMA 
	AND
	    `TABLE_NAME` = C_TABLE_NAME
	AND
	    `COLUMN_NAME` = C_COLUMN_NAME
	INTO s;
	RETURN s;
END $$
DELIMITER ;

DELIMITER $$
DROP FUNCTION IF EXISTS `COLUMN_DIFF` $$
CREATE FUNCTION `COLUMN_DIFF` (
	C_TABLE_SCHEMA VARCHAR(32),
	C_TABLE_NAME VARCHAR(64),
	C_COLUMN_NAME VARCHAR(64),
	C_IS_NULLABLE VARCHAR(8),
	C_COLUMN_TYPE VARCHAR(16),
	C_COLUMN_DEFAULT VARCHAR(64)
) RETURNS INT
BEGIN
	DECLARE s INT;
	IF C_COLUMN_DEFAULT IS NULL
    THEN 
    	SELECT 
			count(1)
		FROM 
			`INFORMATION_SCHEMA`.`COLUMNS`
		WHERE
			`TABLE_SCHEMA` = C_TABLE_SCHEMA 
		and
		    `TABLE_NAME` = C_TABLE_NAME
		and
			`COLUMN_NAME` = C_COLUMN_NAME
		and
		    `IS_NULLABLE` = C_IS_NULLABLE
		and
			`COLUMN_TYPE` = C_COLUMN_TYPE
		and
			`COLUMN_DEFAULT` IS NULL
		INTO s;
    ELSE
    	SELECT 
			count(1)
		FROM 
			`INFORMATION_SCHEMA`.`COLUMNS`
		WHERE
			`TABLE_SCHEMA` = C_TABLE_SCHEMA 
		and
		    `TABLE_NAME` = C_TABLE_NAME
		and
			`COLUMN_NAME` = C_COLUMN_NAME
		and
		    `IS_NULLABLE` = C_IS_NULLABLE
		and
			`COLUMN_TYPE` = C_COLUMN_TYPE
		and
			`COLUMN_DEFAULT` = C_COLUMN_DEFAULT
		INTO s;
    END IF;
	RETURN s;
END $$
DELIMITER ;

DELIMITER $$ 
DROP PROCEDURE IF EXISTS `DML_COLUMN` $$
CREATE PROCEDURE `DML_COLUMN`(
	IN C_TABLE_SCHEMA VARCHAR(32),
	IN C_TABLE_NAME VARCHAR(64),
	IN C_COLUMN_NAME VARCHAR(64),
	IN C_IS_NULLABLE VARCHAR(8),
	IN C_COLUMN_TYPE VARCHAR(16),
	IN C_COLUMN_DEFAULT VARCHAR(64)
)
BEGIN
	SET @C_EXISTS = (SELECT COLUMN_EXISTS(C_TABLE_SCHEMA, C_TABLE_NAME, C_COLUMN_NAME));
	SET @C_DIFF = (SELECT COLUMN_DIFF(C_TABLE_SCHEMA, C_TABLE_NAME, C_COLUMN_NAME,  C_IS_NULLABLE, C_COLUMN_TYPE, C_COLUMN_DEFAULT));
	SET @DML_SQL = 'ALTER TABLE ';
	SET @DML_ACTION = '';

	IF @C_EXISTS = 0
	THEN
		SET @DML_ACTION = ' ADD COLUMN ';
	ELSEIF @C_DIFF = 0
	THEN
		SET @DML_ACTION = ' MODIFY COLUMN ';
	END IF;

	IF LENGTH(@DML_ACTION) > 0
	THEN
		SET @DML_IS_NULLABLE = ' NOT NULL ';

		IF C_IS_NULLABLE = 'YES'
		THEN
			SET @DML_IS_NULLABLE = ' NULL ';
		END IF;

		SET @DML_SQL = concat(@DML_SQL, '`');
		SET @DML_SQL = concat(@DML_SQL, C_TABLE_NAME);
		SET @DML_SQL = concat(@DML_SQL, '`');
		SET @DML_SQL = concat(@DML_SQL, @DML_ACTION);
		SET @DML_SQL = concat(@DML_SQL, '`');
		SET @DML_SQL = concat(@DML_SQL, C_COLUMN_NAME);
		SET @DML_SQL = concat(@DML_SQL, '`');
		SET @DML_SQL = concat(@DML_SQL, ' ');
		SET @DML_SQL = concat(@DML_SQL, C_COLUMN_TYPE);
		SET @DML_SQL = concat(@DML_SQL, @DML_IS_NULLABLE);

		IF C_COLUMN_DEFAULT IS NOT NULL
		THEN
			IF C_COLUMN_DEFAULT = 'CURRENT_TIMESTAMP'
			THEN
				SET @DML_SQL = concat(@DML_SQL, ' DEFAULT ');
				SET @DML_SQL = concat(@DML_SQL, C_COLUMN_DEFAULT);
			ELSE
				SET @DML_SQL = concat(@DML_SQL, ' DEFAULT ');
				SET @DML_SQL = concat(@DML_SQL, '\'');
				SET @DML_SQL = concat(@DML_SQL, C_COLUMN_DEFAULT);
				SET @DML_SQL = concat(@DML_SQL, '\'');
			END IF;
		END IF;
	
	    PREPARE stmt FROM @DML_SQL;
	    EXECUTE stmt;
	END IF;
END 
$$
DELIMITER ;

DELIMITER $$ 
DROP PROCEDURE IF EXISTS `DROP_COLUMN` $$
CREATE PROCEDURE `DROP_COLUMN`(
	IN C_TABLE_SCHEMA VARCHAR(32),
	IN C_TABLE_NAME VARCHAR(64),
	IN C_COLUMN_NAME VARCHAR(64)
)
BEGIN
	SET @C_EXISTS = (SELECT COLUMN_EXISTS(C_TABLE_SCHEMA, C_TABLE_NAME, C_COLUMN_NAME));

	IF @C_EXISTS > 0
	THEN
		SET @DML_SQL = 'ALTER TABLE ';
		SET @DML_SQL = concat(@DML_SQL, '`');
		SET @DML_SQL = concat(@DML_SQL, C_TABLE_NAME);
		SET @DML_SQL = concat(@DML_SQL, '`');
		SET @DML_SQL = concat(@DML_SQL, ' DROP COLUMN ');
		SET @DML_SQL = concat(@DML_SQL, '`');
		SET @DML_SQL = concat(@DML_SQL, C_COLUMN_NAME);
		SET @DML_SQL = concat(@DML_SQL, '`');

		PREPARE stmt FROM @DML_SQL;
	    EXECUTE stmt;
	END IF;
END 
$$
DELIMITER ;

DELIMITER $$
DROP FUNCTION IF EXISTS `INDEX_EXISTS` $$
CREATE FUNCTION  `INDEX_EXISTS` (
	C_TABLE_SCHEMA VARCHAR(32),
	C_TABLE_NAME VARCHAR(64),
	C_INDEX_NAME VARCHAR(64)
) RETURNS INT 
BEGIN
	DECLARE s INT;
	SELECT 
		count(1) INTO s
	FROM 
		`INFORMATION_SCHEMA`.`STATISTICS`
	WHERE
		`TABLE_SCHEMA` = C_TABLE_SCHEMA 
	AND
	    `TABLE_NAME` = C_TABLE_NAME
	AND
	    `INDEX_NAME` = C_INDEX_NAME;

	IF s = 0
	THEN
		SELECT 
			count(1) INTO s
		FROM 
			`INFORMATION_SCHEMA`.`REFERENTIAL_CONSTRAINTS`
		WHERE
			`CONSTRAINT_SCHEMA` = C_TABLE_SCHEMA 
		AND
		    `TABLE_NAME` = C_TABLE_NAME
		AND
		    `CONSTRAINT_NAME` = C_INDEX_NAME;
	END IF;
	RETURN s;
END $$
DELIMITER ;

DELIMITER $$ 
DROP PROCEDURE IF EXISTS `DML_INDEX` $$
CREATE PROCEDURE `DML_INDEX`(
	IN C_TABLE_SCHEMA VARCHAR(32),
	IN C_TABLE_NAME VARCHAR(64),
	IN C_INDEX_NAME VARCHAR(64),
	IN C_DEFINE_INDEX_SQL VARCHAR(256)
)
BEGIN
	SET @C_EXISTS = (SELECT INDEX_EXISTS(C_TABLE_SCHEMA, C_TABLE_NAME, C_INDEX_NAME));
	IF @C_EXISTS = 0
	THEN
		IF (SELECT C_DEFINE_INDEX_SQL LIKE '%FOREIGN KEY%') > 0
		THEN
			SET @DML_SQL = 'ALTER TABLE ';
			SET @DML_SQL = concat(@DML_SQL, C_TABLE_NAME);
			SET @DML_SQL = concat(@DML_SQL, ' ADD CONSTRAINT ');
			SET @DML_SQL = concat(@DML_SQL, C_INDEX_NAME);
			SET @DML_SQL = concat(@DML_SQL, ' ');
			SET @DML_SQL = concat(@DML_SQL, C_DEFINE_INDEX_SQL);

			PREPARE stmt FROM @DML_SQL;
			EXECUTE stmt;
		ELSEIF C_INDEX_NAME = 'PRIMARY'
		THEN
			SET @DML_SQL = 'ALTER TABLE ';
			SET @DML_SQL = concat(@DML_SQL, '`');
			SET @DML_SQL = concat(@DML_SQL, C_TABLE_NAME);
			SET @DML_SQL = concat(@DML_SQL, '`');
			SET @DML_SQL = concat(@DML_SQL, ' ');
			SET @DML_SQL = concat(@DML_SQL, C_DEFINE_INDEX_SQL);

			PREPARE stmt FROM @DML_SQL;
			EXECUTE stmt;
		ELSE
			SET @DML_SQL = 'ALTER TABLE ';
			SET @DML_SQL = concat(@DML_SQL, '`');
			SET @DML_SQL = concat(@DML_SQL, C_TABLE_NAME);
			SET @DML_SQL = concat(@DML_SQL, '`');
			SET @DML_SQL = concat(@DML_SQL, ' ');
			SET @DML_SQL = concat(@DML_SQL, 
				LEFT(C_DEFINE_INDEX_SQL, LOCATE('(', C_DEFINE_INDEX_SQL) - 1),
				' ', C_INDEX_NAME, ' ',
				RIGHT(C_DEFINE_INDEX_SQL, LENGTH(C_DEFINE_INDEX_SQL) - LOCATE('(', C_DEFINE_INDEX_SQL)+1));

			PREPARE stmt FROM @DML_SQL;
			EXECUTE stmt;
		END IF;
	END IF;
END 
$$
DELIMITER ;

DELIMITER $$ 
DROP PROCEDURE IF EXISTS `DROP_INDEX` $$
CREATE PROCEDURE `DROP_INDEX`(
	IN C_TABLE_SCHEMA VARCHAR(32),
	IN C_TABLE_NAME VARCHAR(64),
	IN C_INDEX_NAME VARCHAR(64)
)
BEGIN
	SET @C_EXISTS = (SELECT INDEX_EXISTS(C_TABLE_SCHEMA, C_TABLE_NAME, C_INDEX_NAME));
	IF @C_EXISTS > 0
	THEN
		SET @DML_SQL = 'ALTER TABLE ';
		SET @DML_SQL = concat(@DML_SQL, '`');
		SET @DML_SQL = concat(@DML_SQL, C_TABLE_NAME);
		SET @DML_SQL = concat(@DML_SQL, '`');
		SET @DML_SQL = concat(@DML_SQL, ' DROP INDEX ');
		SET @DML_SQL = concat(@DML_SQL, C_INDEX_NAME);
		PREPARE stmt FROM @DML_SQL;
	    EXECUTE stmt;
	END IF;
END 
$$
DELIMITER ;

DELIMITER $$ 
DROP FUNCTION IF EXISTS `TRIGGER_EXISTS` $$
CREATE FUNCTION `TRIGGER_EXISTS`(
	C_TABLE_SCHEMA VARCHAR(32),
	C_TABLE_NAME VARCHAR(64),
	C_TRIGGER_TIMING VARCHAR(16),
	C_TRIGGER_EVENT VARCHAR(16),
	C_TRIGGER_NAME VARCHAR(64),
	C_TRIGGER_ACTION TEXT
) RETURNS INT 
BEGIN
	DECLARE s INT;
	SELECT 
		count(1) INTO s
	FROM 
		INFORMATION_SCHEMA.TRIGGERS
	WHERE
		TRIGGER_SCHEMA = lower(C_TABLE_SCHEMA) 
	AND
	    EVENT_OBJECT_TABLE = lower(C_TABLE_NAME)
	AND
	    ACTION_TIMING = upper(C_TRIGGER_TIMING)
	AND
	    EVENT_MANIPULATION = upper(C_TRIGGER_EVENT)
	AND
		ACTION_STATEMENT = C_TRIGGER_ACTION;
	RETURN s;
END 
$$
DELIMITER ;

DELIMITER $$
DROP PROCEDURE IF EXISTS `DML_PRIMARY` $$
CREATE PROCEDURE `DML_PRIMARY`(
	IN C_TABLE_SCHEMA VARCHAR(32),
	IN C_TABLE_NAME VARCHAR(64),
	IN C_COLUMN_NAME VARCHAR(64)
)
BEGIN
	SET @INDEX_DEF = concat('ADD PRIMARY KEY(`',C_COLUMN_NAME ,'`)');
	CALL DML_INDEX(C_TABLE_SCHEMA, C_TABLE_NAME, 'PRIMARY', @INDEX_DEF);
END 
$$
DELIMITER ;

DELIMITER $$
DROP PROCEDURE IF EXISTS `DROP_PRIMARY` $$
CREATE PROCEDURE `DROP_PRIMARY`(
	IN C_TABLE_SCHEMA VARCHAR(32),
	IN C_TABLE_NAME VARCHAR(64),
	IN C_COLUMN_NAME VARCHAR(64)
)
BEGIN
	CALL DROP_INDEX(C_TABLE_SCHEMA, C_TABLE_NAME, concat('pk_' ,C_TABLE_NAME ,'_' ,REPLACE(C_COLUMN_NAME, ',', '_')));
END 
$$
DELIMITER ;

DELIMITER $$
DROP PROCEDURE IF EXISTS DML_UNIQUE $$
CREATE PROCEDURE DML_UNIQUE(
	IN C_TABLE_SCHEMA VARCHAR(32),
	IN C_TABLE_NAME VARCHAR(64),
	IN C_COLUMN_NAME VARCHAR(64)
)
BEGIN
	CALL DML_INDEX(C_TABLE_SCHEMA, C_TABLE_NAME, concat('uk_' ,C_TABLE_NAME ,'_' ,REPLACE(C_COLUMN_NAME, ',', '_')), concat('ADD UNIQUE KEY(`' ,C_COLUMN_NAME ,'`)'));
END 
$$
DELIMITER ;

DELIMITER $$
DROP PROCEDURE IF EXISTS DROP_UNIQUE $$
CREATE PROCEDURE DROP_UNIQUE(
	IN C_TABLE_SCHEMA VARCHAR(32),
	IN C_TABLE_NAME VARCHAR(64),
	IN C_COLUMN_NAME VARCHAR(64)
)
BEGIN
	CALL DROP_INDEX(C_TABLE_SCHEMA, C_TABLE_NAME, concat('uk_' ,C_TABLE_NAME ,'_' ,REPLACE(C_COLUMN_NAME, ',', '_')));
END 
$$
DELIMITER ;

DELIMITER $$
DROP PROCEDURE IF EXISTS DML_FOREIGN $$
CREATE PROCEDURE DML_FOREIGN(
	IN C_TABLE_SCHEMA VARCHAR(32),
	IN C_TABLE_NAME VARCHAR(64),
	IN C_COLUMN_NAME VARCHAR(64),
	IN R_TABLE_NAME VARCHAR(64),
	IN R_COLUMN_NAME VARCHAR(64)
) 
BEGIN
	CALL DML_INDEX(
		C_TABLE_SCHEMA, 
		C_TABLE_NAME, 
		concat('fk_' ,C_TABLE_NAME ,'_' ,REPLACE(C_COLUMN_NAME, ',', '_')),
		concat('FOREIGN KEY(',C_COLUMN_NAME,') 
					REFERENCES ',R_TABLE_NAME,'(',R_COLUMN_NAME,')  
						ON UPDATE CASCADE 
						ON DELETE CASCADE'));
END 
$$
DELIMITER ;

DELIMITER $$
DROP PROCEDURE IF EXISTS DROP_FOREIGN;
CREATE PROCEDURE DROP_FOREIGN(
	IN C_TABLE_SCHEMA VARCHAR(32),
	IN C_TABLE_NAME VARCHAR(64),
	IN C_COLUMN_NAME VARCHAR(64)
)
BEGIN
	CALL DROP_INDEX(C_TABLE_SCHEMA, C_TABLE_NAME, concat('fk_' ,C_TABLE_NAME ,'_' ,REPLACE(C_COLUMN_NAME, ',', '_'))); 
END 
DELIMITER $$

DELIMITER $$
DROP FUNCTION IF EXISTS `TABLE_EXISTS` $$
CREATE FUNCTION  `TABLE_EXISTS` (
	C_TABLE_SCHEMA VARCHAR(32),
	C_TABLE_NAME VARCHAR(64)
) RETURNS INT 
BEGIN
	DECLARE s INT;
	SELECT 
		count(1)
	FROM 
		`INFORMATION_SCHEMA`.`TABLES`
	WHERE
		`TABLE_SCHEMA` = C_TABLE_SCHEMA 
	AND
	    `TABLE_NAME` = C_TABLE_NAME
	INTO s;
	RETURN s;
END $$
DELIMITER ;

DELIMITER $$ 
DROP PROCEDURE IF EXISTS `DML_TABLE` $$
CREATE PROCEDURE `DML_TABLE`(
	IN C_TABLE_SCHEMA VARCHAR(32),
	IN C_TABLE_NAME VARCHAR(64)
)
BEGIN
	SET @C_EXISTS = (SELECT TABLE_EXISTS(C_TABLE_SCHEMA, C_TABLE_NAME));
	IF @C_EXISTS <= 0
	THEN
		SET @DML_SQL = concat('CREATE TABLE IF NOT EXISTS `', C_TABLE_NAME, '` (');
		SET @DML_SQL = concat(@DML_SQL, '`id` VARCHAR(36) NOT NULL DEFAULT \'-\'');
		SET @DML_SQL = concat(@DML_SQL, ') ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci');
	
	    PREPARE stmt FROM @DML_SQL;
	    EXECUTE stmt;
		CALL DML_PRIMARY(C_TABLE_SCHEMA, C_TABLE_NAME, 'id');
	END IF;
END 
$$
DELIMITER ;

DELIMITER $$ 
DROP PROCEDURE IF EXISTS create_0struct $$
CREATE PROCEDURE create_0struct(
	IN C_TABLE_SCHEMA VARCHAR(32),
	IN C_TABLE_NAME VARCHAR(64)
)
BEGIN
	CALL DML_TABLE(C_TABLE_SCHEMA, C_TABLE_NAME);
	CALL DML_COLUMN(C_TABLE_SCHEMA, C_TABLE_NAME, 'create_time', 'NO', 'TIMESTAMP', 'CURRENT_TIMESTAMP');
	CALL DML_COLUMN(C_TABLE_SCHEMA, C_TABLE_NAME, 'update_time', 'NO', 'TIMESTAMP', 'CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP');
	CALL DML_COLUMN(C_TABLE_SCHEMA, C_TABLE_NAME, 'features', 'NO', 'JSON', NULL);

	CALL DML_INDEX(C_TABLE_SCHEMA, C_TABLE_NAME, concat('idx_' ,C_TABLE_NAME ,'_create_time'), concat('ADD KEY(`create_time`)'));
	CALL DML_INDEX(C_TABLE_SCHEMA, C_TABLE_NAME, concat('idx_' ,C_TABLE_NAME ,'_update_time'), concat('ADD KEY(`update_time`)'));
END 
$$
DELIMITER ;

DELIMITER $$ 
DROP PROCEDURE IF EXISTS create_0flagstruct $$
CREATE PROCEDURE create_0flagstruct(
	IN C_TABLE_SCHEMA VARCHAR(32),
	IN C_TABLE_NAME VARCHAR(64)
)
BEGIN
	CALL DML_TABLE(C_TABLE_SCHEMA, C_TABLE_NAME);
	CALL DML_COLUMN(C_TABLE_SCHEMA, C_TABLE_NAME, 'create_time', 'NO', 'TIMESTAMP', 'CURRENT_TIMESTAMP');
	CALL DML_COLUMN(C_TABLE_SCHEMA, C_TABLE_NAME, 'update_time', 'NO', 'TIMESTAMP', 'CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP');
	CALL DML_COLUMN(C_TABLE_SCHEMA, C_TABLE_NAME, 'flag', 'NO', 'INT(4)', '0');
	CALL DML_COLUMN(C_TABLE_SCHEMA, C_TABLE_NAME, 'features', 'NO', 'JSON', NULL);
	CALL DML_INDEX(C_TABLE_SCHEMA, C_TABLE_NAME, concat('idx_' ,C_TABLE_NAME ,'_create_time'), concat('ADD KEY(`create_time`)'));
	CALL DML_INDEX(C_TABLE_SCHEMA, C_TABLE_NAME, concat('idx_' ,C_TABLE_NAME ,'_update_time'), concat('ADD KEY(`update_time`)'));
END 
$$
DELIMITER ;

DELIMITER $$
DROP FUNCTION IF EXISTS `PARTITION_TABLE_EXISTS` $$
CREATE FUNCTION  `PARTITION_TABLE_EXISTS` (
	C_TABLE_SCHEMA VARCHAR(32),
	C_TABLE_NAME VARCHAR(64)
) RETURNS INT 
BEGIN
	DECLARE s INT;
	SELECT 
		count(1)
	FROM 
		`INFORMATION_SCHEMA`.`PARTITIONS`
	WHERE
		`TABLE_SCHEMA` = C_TABLE_SCHEMA 
	AND
	    `TABLE_NAME` = C_TABLE_NAME
	AND
	    `PARTITION_NAME` IS NOT NULL
	INTO s;
	RETURN s;
END $$
DELIMITER ;

DELIMITER $$
DROP FUNCTION IF EXISTS `PARTITION_EXISTS` $$
CREATE FUNCTION  `PARTITION_EXISTS` (
	C_TABLE_SCHEMA VARCHAR(32),
	C_TABLE_NAME VARCHAR(64),
	C_PARTITION_NAME VARCHAR(64)
) RETURNS INT 
BEGIN
	DECLARE s INT;
	SELECT 
		count(1)
	FROM 
		`INFORMATION_SCHEMA`.`PARTITIONS`
	WHERE
		`TABLE_SCHEMA` = C_TABLE_SCHEMA 
	AND
	    `TABLE_NAME` = C_TABLE_NAME
	AND
	    `PARTITION_NAME` = C_PARTITION_NAME
	INTO s;
	RETURN s;
END $$
DELIMITER ;

DELIMITER $$ 
DROP PROCEDURE IF EXISTS `DML_MONTH_PARTITION_TABLE` $$
CREATE PROCEDURE `DML_MONTH_PARTITION_TABLE`(
	IN C_TABLE_SCHEMA VARCHAR(32),
	IN C_TABLE_NAME VARCHAR(64)
)
BEGIN
	SET @C_EXISTS = (SELECT PARTITION_TABLE_EXISTS(C_TABLE_SCHEMA, C_TABLE_NAME));
	IF @C_EXISTS <= 0
	THEN
		SET @DML_MONTH = (DATE_FORMAT(DATE_ADD(CURDATE(),INTERVAL 1 MONTH) ,'%Y-%m-01')); 
		SET @DML_PARTITION_NAME = concat('zadp_' ,C_TABLE_NAME);
		SET @DML_PARTITION_NAME = concat(@DML_PARTITION_NAME, '_');
		SET @DML_PARTITION_NAME = concat(@DML_PARTITION_NAME, DATE_FORMAT(NOW() ,'%Y%m'));

		SET @DML_SQL = ' ALTER TABLE ';
		SET @DML_SQL = concat(@DML_SQL, '`');
		SET @DML_SQL = concat(@DML_SQL, C_TABLE_NAME);
		SET @DML_SQL = concat(@DML_SQL, '`');
		SET @DML_SQL = concat(@DML_SQL, ' PARTITION BY RANGE (UNIX_TIMESTAMP(`create_time`)) ');
		SET @DML_SQL = concat(@DML_SQL, ' ( PARTITION ');
		SET @DML_SQL = concat(@DML_SQL, @DML_PARTITION_NAME);
		SET @DML_SQL = concat(@DML_SQL, ' VALUES LESS THAN (UNIX_TIMESTAMP(\'');
		SET @DML_SQL = concat(@DML_SQL, @DML_MONTH);
		SET @DML_SQL = concat(@DML_SQL, '\')) ENGINE = InnoDB) ');
		PREPARE stmt FROM @DML_SQL;
	    EXECUTE stmt;

	    CALL PARTITION_AUTO_CREATE(C_TABLE_SCHEMA ,C_TABLE_NAME);
	END IF;
END 
$$
DELIMITER ;

DELIMITER $$ 
DROP PROCEDURE IF EXISTS `DML_MONTH_PARTITION` $$
CREATE PROCEDURE `DML_MONTH_PARTITION`(
	IN C_TABLE_SCHEMA VARCHAR(32),
	IN C_TABLE_NAME VARCHAR(64),
	IN C_PARTITION_NAME VARCHAR(64),
	IN C_PARTITION_MONTH VARCHAR(32)
)
BEGIN
	SET @CT_EXISTS = (SELECT PARTITION_TABLE_EXISTS(C_TABLE_SCHEMA, C_TABLE_NAME));
	SET @C_EXISTS = (SELECT PARTITION_EXISTS(C_TABLE_SCHEMA, C_TABLE_NAME ,C_PARTITION_NAME));
	IF @CT_EXISTS > 0 AND @C_EXISTS <= 0
	THEN
		SET @DML_SQL = ' ALTER TABLE ';
		SET @DML_SQL = concat(@DML_SQL, '`');
		SET @DML_SQL = concat(@DML_SQL, C_TABLE_NAME);
		SET @DML_SQL = concat(@DML_SQL, '`');
		SET @DML_SQL = concat(@DML_SQL, ' ADD PARTITION ');
		SET @DML_SQL = concat(@DML_SQL, ' ( PARTITION ');
		SET @DML_SQL = concat(@DML_SQL, C_PARTITION_NAME);
		SET @DML_SQL = concat(@DML_SQL, ' VALUES LESS THAN (UNIX_TIMESTAMP(\'');
		SET @DML_SQL = concat(@DML_SQL, C_PARTITION_MONTH);
		SET @DML_SQL = concat(@DML_SQL, '\')) ENGINE = InnoDB) ');
		PREPARE stmt FROM @DML_SQL;
	    EXECUTE stmt;
	END IF;
END 
$$
DELIMITER ;

DELIMITER $$
DROP PROCEDURE IF EXISTS `PARTITION_AUTO_CREATE`$$
CREATE PROCEDURE `PARTITION_AUTO_CREATE`(
	IN C_TABLE_SCHEMA VARCHAR(32),
	IN C_TABLE_NAME VARCHAR(64)
)
BEGIN
 	SET @NEXT_DATE = DATE_FORMAT(DATE_ADD(CURDATE(),INTERVAL 2 MONTH),'%Y-%m-01');
 	SET @NEXT_PARTITION_NAME = concat('zadp_' ,C_TABLE_NAME);
	SET @NEXT_PARTITION_NAME = concat(@NEXT_PARTITION_NAME, '_');
	SET @NEXT_PARTITION_NAME = concat(@NEXT_PARTITION_NAME, DATE_FORMAT(DATE_ADD(CURDATE(),INTERVAL 1 MONTH) ,'%Y%m'));
	CALL DML_MONTH_PARTITION(C_TABLE_SCHEMA ,C_TABLE_NAME ,@NEXT_PARTITION_NAME ,@NEXT_DATE);
END$$
DELIMITER ;

-- DELIMITER ||  
-- DROP EVENT IF EXISTS `ZADP_AUTO_CREATE_EVENT` ||
-- CREATE EVENT `ZADP_AUTO_CREATE_EVENT`
-- 	ON SCHEDULE
-- 		EVERY 1 DAY STARTS DATE_FORMAT(DATE_ADD(CURDATE(),INTERVAL 1 DAY), '%Y-%m-%d 03:05:00')
-- 	ON COMPLETION PRESERVE ENABLE 
-- 	DO  
--       	BEGIN
-- 			DECLARE D_FLAG int DEFAULT 0;
-- 			DECLARE D_TABLE_NAME varchar(36);

-- 			DECLARE ZADP_PARTITION_TABLE CURSOR FOR 
-- 				SELECT 
-- 					TABLE_NAME
-- 				FROM 
-- 					information_schema.PARTITIONS 
-- 				WHERE 
-- 					TABLE_SCHEMA = database()
-- 				AND
-- 					PARTITION_METHOD = 'RANGE' 
-- 				AND 
-- 					PARTITION_EXPRESSION = 'unix_timestamp(`create_time`)' 
-- 				AND 
-- 					PARTITION_NAME IS NOT NULL 
-- 				AND 
-- 					PARTITION_NAME LIKE 'zadp_%'
-- 				GROUP BY
-- 					TABLE_NAME;

-- 			DECLARE CONTINUE HANDLER FOR NOT FOUND SET D_FLAG = 1;
-- 			OPEN ZADP_PARTITION_TABLE;
-- 				FETCH ZADP_PARTITION_TABLE INTO D_TABLE_NAME;
-- 				WHILE D_FLAG <> 1 DO
-- 					CALL PARTITION_AUTO_CREATE(database() ,D_TABLE_NAME);
-- 					FETCH ZADP_PARTITION_TABLE INTO D_TABLE_NAME;
-- 				END WHILE;
-- 			CLOSE ZADP_PARTITION_TABLE;
--       	END ||  
-- DELIMITER ;

-- // INIT MYSQL AUTOSQLCONF DML END 


