-- //
-- //  autosqlconf.mysql.sql
-- //  zero-framework mysql autosqlconf script
-- //
-- //  Created by Zero on 2020/11/11.
-- //  Copyright © 2020年 RyeWhiskey. All rights reserved.
-- //

-- // INIT MYSQL AUTOSQLCONF DML BEGIN 

CREATE DATABASE IF NOT EXISTS `<databaseName>` DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;	
USE `<databaseName>`;

DELIMITER $$
DROP FUNCTION IF EXISTS `COLUMN_EXISTS` $$
CREATE FUNCTION  `COLUMN_EXISTS` (
	C_TABLE_SCHEMA VARCHAR(32),
	C_TABLE_NAME VARCHAR(64),
	C_COLUMN_NAME VARCHAR(64)
) RETURNS INT 
BEGIN
	DECLARE s INT;
	SELECT 
		count(1)
	FROM 
		`INFORMATION_SCHEMA`.`COLUMNS`
	WHERE
		`TABLE_SCHEMA` = C_TABLE_SCHEMA 
	AND
	    `TABLE_NAME` = C_TABLE_NAME
	AND
	    `COLUMN_NAME` = C_COLUMN_NAME
	INTO s;
	RETURN s;
END $$
DELIMITER ;

DELIMITER $$
DROP FUNCTION IF EXISTS `COLUMN_DIFF` $$
CREATE FUNCTION `COLUMN_DIFF` (
	C_TABLE_SCHEMA VARCHAR(32),
	C_TABLE_NAME VARCHAR(64),
	C_COLUMN_NAME VARCHAR(64),
	C_IS_NULLABLE VARCHAR(8),
	C_COLUMN_TYPE VARCHAR(16),
	C_COLUMN_DEFAULT VARCHAR(64)
) RETURNS INT
BEGIN
	DECLARE s INT;
	IF C_COLUMN_DEFAULT IS NULL
    THEN 
    	SELECT 
			count(1)
		FROM 
			`INFORMATION_SCHEMA`.`COLUMNS`
		WHERE
			`TABLE_SCHEMA` = C_TABLE_SCHEMA 
		and
		    `TABLE_NAME` = C_TABLE_NAME
		and
			`COLUMN_NAME` = C_COLUMN_NAME
		and
		    `IS_NULLABLE` = C_IS_NULLABLE
		and
			`COLUMN_TYPE` = C_COLUMN_TYPE
		and
			`COLUMN_DEFAULT` IS NULL
		INTO s;
    ELSE
    	SELECT 
			count(1)
		FROM 
			`INFORMATION_SCHEMA`.`COLUMNS`
		WHERE
			`TABLE_SCHEMA` = C_TABLE_SCHEMA 
		and
		    `TABLE_NAME` = C_TABLE_NAME
		and
			`COLUMN_NAME` = C_COLUMN_NAME
		and
		    `IS_NULLABLE` = C_IS_NULLABLE
		and
			`COLUMN_TYPE` = C_COLUMN_TYPE
		and
			`COLUMN_DEFAULT` = C_COLUMN_DEFAULT
		INTO s;
    END IF;
	RETURN s;
END $$
DELIMITER ;

DELIMITER $$ 
DROP PROCEDURE IF EXISTS `DML_COLUMN` $$
CREATE PROCEDURE `DML_COLUMN`(
	IN C_TABLE_SCHEMA VARCHAR(32),
	IN C_TABLE_NAME VARCHAR(64),
	IN C_COLUMN_NAME VARCHAR(64),
	IN C_IS_NULLABLE VARCHAR(8),
	IN C_COLUMN_TYPE VARCHAR(16),
	IN C_COLUMN_DEFAULT VARCHAR(64),
	IN C_CHARACTER_SET VARCHAR(64)
)
BEGIN
	SET @C_EXISTS = (SELECT COLUMN_EXISTS(C_TABLE_SCHEMA, C_TABLE_NAME, C_COLUMN_NAME));
	SET @C_DIFF = (SELECT COLUMN_DIFF(C_TABLE_SCHEMA, C_TABLE_NAME, C_COLUMN_NAME,  C_IS_NULLABLE, C_COLUMN_TYPE, C_COLUMN_DEFAULT));
	SET @DML_SQL = 'ALTER TABLE ';
	SET @DML_ACTION = '';

	IF @C_EXISTS = 0
	THEN
		SET @DML_ACTION = ' ADD COLUMN ';
	ELSEIF @C_DIFF = 0
	THEN
		SET @DML_ACTION = ' MODIFY COLUMN ';
	END IF;

	IF LENGTH(@DML_ACTION) > 0
	THEN
		SET @DML_CHARACTER_SET = C_CHARACTER_SET;

		IF C_CHARACTER_SET IS NULL
		THEN
			SET @DML_CHARACTER_SET = '';
		END IF;

		SET @DML_IS_NULLABLE = ' NOT NULL ';

		IF C_IS_NULLABLE = 'YES'
		THEN
			SET @DML_IS_NULLABLE = ' NULL ';
		END IF;

		SET @DML_SQL = concat(@DML_SQL, '`');
		SET @DML_SQL = concat(@DML_SQL, C_TABLE_NAME);
		SET @DML_SQL = concat(@DML_SQL, '`');
		SET @DML_SQL = concat(@DML_SQL, @DML_ACTION);
		SET @DML_SQL = concat(@DML_SQL, '`');
		SET @DML_SQL = concat(@DML_SQL, C_COLUMN_NAME);
		SET @DML_SQL = concat(@DML_SQL, '`');
		SET @DML_SQL = concat(@DML_SQL, ' ');
		SET @DML_SQL = concat(@DML_SQL, C_COLUMN_TYPE);
		SET @DML_SQL = concat(@DML_SQL, ' ');
		SET @DML_SQL = concat(@DML_SQL, @DML_CHARACTER_SET);
		SET @DML_SQL = concat(@DML_SQL, @DML_IS_NULLABLE);

		IF C_COLUMN_DEFAULT IS NOT NULL
		THEN
			IF C_COLUMN_DEFAULT = 'CURRENT_TIMESTAMP'
			THEN
				SET @DML_SQL = concat(@DML_SQL, ' DEFAULT ');
				SET @DML_SQL = concat(@DML_SQL, C_COLUMN_DEFAULT);
			ELSE
				SET @DML_SQL = concat(@DML_SQL, ' DEFAULT ');
				SET @DML_SQL = concat(@DML_SQL, '\'');
				SET @DML_SQL = concat(@DML_SQL, C_COLUMN_DEFAULT);
				SET @DML_SQL = concat(@DML_SQL, '\'');
			END IF;
		END IF;
	
	    PREPARE stmt FROM @DML_SQL;
	    EXECUTE stmt;
	END IF;
END 
$$
DELIMITER ;

DELIMITER $$ 
DROP PROCEDURE IF EXISTS `DROP_COLUMN` $$
CREATE PROCEDURE `DROP_COLUMN`(
	IN C_TABLE_SCHEMA VARCHAR(32),
	IN C_TABLE_NAME VARCHAR(64),
	IN C_COLUMN_NAME VARCHAR(64)
)
BEGIN
	SET @C_EXISTS = (SELECT COLUMN_EXISTS(C_TABLE_SCHEMA, C_TABLE_NAME, C_COLUMN_NAME));

	IF @C_EXISTS > 0
	THEN
		SET @DML_SQL = 'ALTER TABLE ';
		SET @DML_SQL = concat(@DML_SQL, '`');
		SET @DML_SQL = concat(@DML_SQL, C_TABLE_NAME);
		SET @DML_SQL = concat(@DML_SQL, '`');
		SET @DML_SQL = concat(@DML_SQL, ' DROP COLUMN ');
		SET @DML_SQL = concat(@DML_SQL, '`');
		SET @DML_SQL = concat(@DML_SQL, C_COLUMN_NAME);
		SET @DML_SQL = concat(@DML_SQL, '`');

		PREPARE stmt FROM @DML_SQL;
	    EXECUTE stmt;
	END IF;
END 
$$
DELIMITER ;

DELIMITER $$
DROP FUNCTION IF EXISTS `INDEX_EXISTS` $$
CREATE FUNCTION  `INDEX_EXISTS` (
	C_TABLE_SCHEMA VARCHAR(32),
	C_TABLE_NAME VARCHAR(64),
	C_INDEX_NAME VARCHAR(64)
) RETURNS INT 
BEGIN
	DECLARE s INT;
	SELECT 
		count(1)
	FROM 
		`INFORMATION_SCHEMA`.`STATISTICS`
	WHERE
		`TABLE_SCHEMA` = C_TABLE_SCHEMA 
	AND
	    `TABLE_NAME` = C_TABLE_NAME
	AND
	    `INDEX_NAME` = C_INDEX_NAME
	INTO s;

	IF s = 0
	THEN
		SELECT 
			count(1)
		FROM 
			`INFORMATION_SCHEMA`.`REFERENTIAL_CONSTRAINTS`
		WHERE
			`CONSTRAINT_SCHEMA` = C_TABLE_SCHEMA 
		AND
		    `TABLE_NAME` = C_TABLE_NAME
		AND
		    `CONSTRAINT_NAME` = C_INDEX_NAME
		INTO s;
	END IF;
	RETURN s;
END $$
DELIMITER ;

DELIMITER $$ 
DROP PROCEDURE IF EXISTS `DML_INDEX` $$
CREATE PROCEDURE `DML_INDEX`(
	IN C_TABLE_SCHEMA VARCHAR(32),
	IN C_TABLE_NAME VARCHAR(64),
	IN C_INDEX_NAME VARCHAR(64),
	IN C_DML_INDEX_ACTION VARCHAR(32),
	IN C_DEFINE_INDEX_SQL VARCHAR(256)
)
BEGIN
	SET @C_EXISTS = (SELECT INDEX_EXISTS(C_TABLE_SCHEMA, C_TABLE_NAME, C_INDEX_NAME));
	IF @C_EXISTS = 0
	THEN
		SET @DML_SQL = 'ALTER TABLE ';
		SET @DML_SQL = concat(@DML_SQL, '`');
		SET @DML_SQL = concat(@DML_SQL, C_TABLE_NAME);
		SET @DML_SQL = concat(@DML_SQL, '`');
		SET @DML_SQL = concat(@DML_SQL, ' ');
		SET @DML_SQL = concat(@DML_SQL, C_DML_INDEX_ACTION);

		IF C_INDEX_NAME != 'PRIMARY'
		THEN
			SET @DML_SQL = concat(@DML_SQL, ' ');
			SET @DML_SQL = concat(@DML_SQL, C_INDEX_NAME);
		END IF;

		SET @DML_SQL = concat(@DML_SQL, ' ');
		SET @DML_SQL = concat(@DML_SQL, C_DEFINE_INDEX_SQL);
		PREPARE stmt FROM @DML_SQL;
	    EXECUTE stmt;
	END IF;
END 
$$
DELIMITER ;

DELIMITER $$ 
DROP PROCEDURE IF EXISTS `DROP_INDEX` $$
CREATE PROCEDURE `DROP_INDEX`(
	IN C_TABLE_SCHEMA VARCHAR(32),
	IN C_TABLE_NAME VARCHAR(64),
	IN C_INDEX_NAME VARCHAR(64)
)
BEGIN
	SET @C_EXISTS = (SELECT INDEX_EXISTS(C_TABLE_SCHEMA, C_TABLE_NAME, C_INDEX_NAME));
	IF @C_EXISTS > 0
	THEN
		SET @DML_SQL = 'ALTER TABLE ';
		SET @DML_SQL = concat(@DML_SQL, '`');
		SET @DML_SQL = concat(@DML_SQL, C_TABLE_NAME);
		SET @DML_SQL = concat(@DML_SQL, '`');
		SET @DML_SQL = concat(@DML_SQL, ' DROP INDEX ');
		SET @DML_SQL = concat(@DML_SQL, C_INDEX_NAME);
		PREPARE stmt FROM @DML_SQL;
	    EXECUTE stmt;
	END IF;
END 
$$
DELIMITER ;

DELIMITER $$
DROP FUNCTION IF EXISTS `TABLE_EXISTS` $$
CREATE FUNCTION  `TABLE_EXISTS` (
	C_TABLE_SCHEMA VARCHAR(32),
	C_TABLE_NAME VARCHAR(64)
) RETURNS INT 
BEGIN
	DECLARE s INT;
	SELECT 
		count(1)
	FROM 
		`INFORMATION_SCHEMA`.`TABLES`
	WHERE
		`TABLE_SCHEMA` = C_TABLE_SCHEMA 
	AND
	    `TABLE_NAME` = C_TABLE_NAME
	INTO s;
	RETURN s;
END $$
DELIMITER ;

DELIMITER $$ 
DROP PROCEDURE IF EXISTS `DML_TABLE` $$
CREATE PROCEDURE `DML_TABLE`(
	IN C_TABLE_SCHEMA VARCHAR(32),
	IN C_TABLE_NAME VARCHAR(64)
)
BEGIN
	SET @C_EXISTS = (SELECT TABLE_EXISTS(C_TABLE_SCHEMA, C_TABLE_NAME));
	IF @C_EXISTS <= 0
	THEN
		SET @DML_SQL = concat('CREATE TABLE IF NOT EXISTS `', C_TABLE_NAME, '` (');
		SET @DML_SQL = concat(@DML_SQL, '`id` VARCHAR(36) NOT NULL DEFAULT \'-\',');
		SET @DML_SQL = concat(@DML_SQL, '`create_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,');
		SET @DML_SQL = concat(@DML_SQL, '`update_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,');
		SET @DML_SQL = concat(@DML_SQL, '`flag` INT(4) NOT NULL DEFAULT 0 ');
		SET @DML_SQL = concat(@DML_SQL, ') ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci');
	
	    PREPARE stmt FROM @DML_SQL;
	    EXECUTE stmt;
	END IF;
END 
$$
DELIMITER ;

DELIMITER $$
DROP FUNCTION IF EXISTS `PARTITION_TABLE_EXISTS` $$
CREATE FUNCTION  `PARTITION_TABLE_EXISTS` (
	C_TABLE_SCHEMA VARCHAR(32),
	C_TABLE_NAME VARCHAR(64)
) RETURNS INT 
BEGIN
	DECLARE s INT;
	SELECT 
		count(1)
	FROM 
		`INFORMATION_SCHEMA`.`PARTITIONS`
	WHERE
		`TABLE_SCHEMA` = C_TABLE_SCHEMA 
	AND
	    `TABLE_NAME` = C_TABLE_NAME
	AND
	    `PARTITION_NAME` IS NOT NULL
	INTO s;
	RETURN s;
END $$
DELIMITER ;

DELIMITER $$
DROP FUNCTION IF EXISTS `PARTITION_EXISTS` $$
CREATE FUNCTION  `PARTITION_EXISTS` (
	C_TABLE_SCHEMA VARCHAR(32),
	C_TABLE_NAME VARCHAR(64),
	C_PARTITION_NAME VARCHAR(64)
) RETURNS INT 
BEGIN
	DECLARE s INT;
	SELECT 
		count(1)
	FROM 
		`INFORMATION_SCHEMA`.`PARTITIONS`
	WHERE
		`TABLE_SCHEMA` = C_TABLE_SCHEMA 
	AND
	    `TABLE_NAME` = C_TABLE_NAME
	AND
	    `PARTITION_NAME` = C_PARTITION_NAME
	INTO s;
	RETURN s;
END $$
DELIMITER ;

DELIMITER $$ 
DROP PROCEDURE IF EXISTS `DML_MONTH_PARTITION_TABLE` $$
CREATE PROCEDURE `DML_MONTH_PARTITION_TABLE`(
	IN C_TABLE_SCHEMA VARCHAR(32),
	IN C_TABLE_NAME VARCHAR(64)
)
BEGIN
	SET @C_EXISTS = (SELECT PARTITION_TABLE_EXISTS(C_TABLE_SCHEMA, C_TABLE_NAME));
	IF @C_EXISTS <= 0
	THEN
		SET @DML_MONTH = (DATE_FORMAT(DATE_ADD(CURDATE(),INTERVAL 1 MONTH) ,'%Y-%m-01')); 
		SET @DML_PARTITION_NAME = concat('zadp_' ,C_TABLE_NAME);
		SET @DML_PARTITION_NAME = concat(@DML_PARTITION_NAME, '_');
		SET @DML_PARTITION_NAME = concat(@DML_PARTITION_NAME, DATE_FORMAT(NOW() ,'%Y%m'));

		SET @DML_SQL = ' ALTER TABLE ';
		SET @DML_SQL = concat(@DML_SQL, '`');
		SET @DML_SQL = concat(@DML_SQL, C_TABLE_NAME);
		SET @DML_SQL = concat(@DML_SQL, '`');
		SET @DML_SQL = concat(@DML_SQL, ' PARTITION BY RANGE (UNIX_TIMESTAMP(`create_time`)) ');
		SET @DML_SQL = concat(@DML_SQL, ' ( PARTITION ');
		SET @DML_SQL = concat(@DML_SQL, @DML_PARTITION_NAME);
		SET @DML_SQL = concat(@DML_SQL, ' VALUES LESS THAN (UNIX_TIMESTAMP(\'');
		SET @DML_SQL = concat(@DML_SQL, @DML_MONTH);
		SET @DML_SQL = concat(@DML_SQL, '\')) ENGINE = InnoDB) ');
		PREPARE stmt FROM @DML_SQL;
	    EXECUTE stmt;

	    CALL PARTITION_AUTO_CREATE(C_TABLE_SCHEMA ,C_TABLE_NAME);
	END IF;
END 
$$
DELIMITER ;

DELIMITER $$ 
DROP PROCEDURE IF EXISTS `DML_MONTH_PARTITION` $$
CREATE PROCEDURE `DML_MONTH_PARTITION`(
	IN C_TABLE_SCHEMA VARCHAR(32),
	IN C_TABLE_NAME VARCHAR(64),
	IN C_PARTITION_NAME VARCHAR(64),
	IN C_PARTITION_MONTH VARCHAR(32)
)
BEGIN
	SET @CT_EXISTS = (SELECT PARTITION_TABLE_EXISTS(C_TABLE_SCHEMA, C_TABLE_NAME));
	SET @C_EXISTS = (SELECT PARTITION_EXISTS(C_TABLE_SCHEMA, C_TABLE_NAME ,C_PARTITION_NAME));
	IF @CT_EXISTS > 0 AND @C_EXISTS <= 0
	THEN
		SET @DML_SQL = ' ALTER TABLE ';
		SET @DML_SQL = concat(@DML_SQL, '`');
		SET @DML_SQL = concat(@DML_SQL, C_TABLE_NAME);
		SET @DML_SQL = concat(@DML_SQL, '`');
		SET @DML_SQL = concat(@DML_SQL, ' ADD PARTITION ');
		SET @DML_SQL = concat(@DML_SQL, ' ( PARTITION ');
		SET @DML_SQL = concat(@DML_SQL, C_PARTITION_NAME);
		SET @DML_SQL = concat(@DML_SQL, ' VALUES LESS THAN (UNIX_TIMESTAMP(\'');
		SET @DML_SQL = concat(@DML_SQL, C_PARTITION_MONTH);
		SET @DML_SQL = concat(@DML_SQL, '\')) ENGINE = InnoDB) ');
		PREPARE stmt FROM @DML_SQL;
	    EXECUTE stmt;
	END IF;
END 
$$
DELIMITER ;

DELIMITER $$
DROP PROCEDURE IF EXISTS `PARTITION_AUTO_CREATE`$$
CREATE PROCEDURE `PARTITION_AUTO_CREATE`(
	IN C_TABLE_SCHEMA VARCHAR(32),
	IN C_TABLE_NAME VARCHAR(64)
)
BEGIN
 	SET @NEXT_DATE = DATE_FORMAT(DATE_ADD(CURDATE(),INTERVAL 2 MONTH),'%Y-%m-01');
 	SET @NEXT_PARTITION_NAME = concat('zadp_' ,C_TABLE_NAME);
	SET @NEXT_PARTITION_NAME = concat(@NEXT_PARTITION_NAME, '_');
	SET @NEXT_PARTITION_NAME = concat(@NEXT_PARTITION_NAME, DATE_FORMAT(DATE_ADD(CURDATE(),INTERVAL 1 MONTH) ,'%Y%m'));
	CALL DML_MONTH_PARTITION(C_TABLE_SCHEMA ,C_TABLE_NAME ,@NEXT_PARTITION_NAME ,@NEXT_DATE);
END$$
DELIMITER ;

DELIMITER ||  
DROP EVENT IF EXISTS `ZADP_AUTO_CREATE_EVENT` ||
CREATE EVENT `ZADP_AUTO_CREATE_EVENT`
	ON SCHEDULE
		EVERY 1 DAY STARTS DATE_FORMAT(DATE_ADD(CURDATE(),INTERVAL 1 DAY), '%Y-%m-%d 03:05:00')
	ON COMPLETION PRESERVE ENABLE 
	DO  
      	BEGIN
			DECLARE D_FLAG int DEFAULT 0;
			DECLARE D_TABLE_NAME varchar(36);

			DECLARE ZADP_PARTITION_TABLE CURSOR FOR 
				SELECT 
					TABLE_NAME
				FROM 
					information_schema.PARTITIONS 
				WHERE 
					TABLE_SCHEMA = database()
				AND
					PARTITION_METHOD = 'RANGE' 
				AND 
					PARTITION_EXPRESSION = 'unix_timestamp(`create_time`)' 
				AND 
					PARTITION_NAME IS NOT NULL 
				AND 
					PARTITION_NAME LIKE 'zadp_%'
				GROUP BY
					TABLE_NAME;

			DECLARE CONTINUE HANDLER FOR NOT FOUND SET D_FLAG = 1;
			OPEN ZADP_PARTITION_TABLE;
				FETCH ZADP_PARTITION_TABLE INTO D_TABLE_NAME;
				WHILE D_FLAG <> 1 DO
					CALL PARTITION_AUTO_CREATE(database() ,D_TABLE_NAME);
					FETCH ZADP_PARTITION_TABLE INTO D_TABLE_NAME;
				END WHILE;
			CLOSE ZADP_PARTITION_TABLE;
      	END ||  
DELIMITER ;

-- // INIT MYSQL AUTOSQLCONF DML END 


